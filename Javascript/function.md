자바스크립트의 함수(function)는 매우 특별한 존재입니다. 자세히 알아봅시다!

## 함수(Function)
> 함수는 이름과 매개변수를 갖고, 필요한 때에 호출하여 코드 블록에 작성한 문들을 일괄적으로 실행할 수 있습니다.

즉, 특정 작업을 수행하기 위해 필요한 문(statement)의 집합을 정의한 코드 블록이 함수입니다. 이 함수는 아래와 같은 기능을 할 수 있습니다.
1. 반복적으로 작성되는 코드를 함수로 정의하여 `재사용`
   - 함수의 아이덴티티는 **재사용성**에 있습니다.
2. 객체 생성
3. 객체의 행위 정의(메서드로 동작)
4. 정보 은닉
5. 클로저
6. 모듈화

기능을 보면 이상하죠? 마치 함수가 객체처럼 쓰일 수 있는 것 같아요. 놀랍게도 자바스크립트의 함수는 호출할 수 있는 `객체(First-Class Object)`로서 [일급 객체](https://ko.wikipedia.org/wiki/%EC%9D%BC%EA%B8%89_%EA%B0%9D%EC%B2%B4)라고 불립니다. 변수나 객체, 배열의 프로퍼티(메서드)로 정의할 수 있고, 다른 함수에 전달하는 인수로도 사용할 수 있으며, 다른 함수의 반환값이 될 수도 있습니다.
> 일급 객체에 대한 내용은 분리하여 다루도록 합니다.

### 함수 정의
> 함수를 정의하는 방식은 세 가지로 분류할 수 있습니다.

1. 함수 선언문(Function Declaration) : `function` 키워드와 함수명, 매개변수 목록, 함수 몸체로 구성됩니다.
    ```js
    function sum(a, b){
      return a + b;
    }
    
    console.log(sum(1, 2)); // 3
    ```
    - 함수 선언문은 **함수명을 생략할 수 없습니다**.
    - 자바스크립트의 함수는 매개변수의 타입을 기술하지 않으며, 매개변수를 넘기지 않으면 undefined로 선언됩니다.
      ```js
      function sum(a, b){
        return a + b;
      }
      console.log(sum());   // NaN
      ```
    - 함수 몸체는 함수 호출 시 실행되는 문들의 집합닙니다. 중괄호(`{}`)로 감싸지며 `return` 문으로 함수 실행의 결과(`return value`)를 반환할 수 있습니다.

2. 함수 표현식(Function Expression) : 함수 리터럴 방식으로 함수를 정의하고 변수에 할당합니다. 종류가 두 가지 존재하는데, 예제로 살펴봅니다.
     - 기명 함수 표현식 : 함수명을 `지정하는` 방법입니다.
       ```js
       const foo = function sum(a, b){
         return a + b;
       }

       console.log(foo(1, 2)); // 3
       console.log(sum(1, 2)); // Uncaught ReferenceError: multiply is not defined
       ```
       - 이처럼 변수에 할당할 수 있는 이유는 함수가 `일급 객체`로 평가되기 때문입니다. 해당 변수는 원시 값이 아니라 할당된 함수를 가리키는 참조값을 저장하며, 함수명이 아닌 변수명으로 함수를 호출할 수 있습니다.
     - 익명 함수 표현식 : 함수명을 `생략하는` 방법입니다.
       ```js
       const bar = function(a, b){
         return a + b;
       }

       const foo = bar;

       console.log(bar(1, 2)); // 3
       console.log(foo(1, 2)); // 3
       ```

3. Function 생성자 함수 : 사용하지 않습니다!
    ```js
    const sum = new Function('a', 'b', 'return a + b');
    
    console.log(sum); // 3
    ```

함수를 정의하는 방식이 세 가지나 됩니다. 그러나 반환하는 결과는 동일하네요? 대체 뭐가 다르길래 이렇게 나눠진 걸까요? 여기서 함수 호이스팅이 등장합니다.

<br>

### 함수 호이스팅(Function Hoisting)
> 자바스크립트는 모든 선언을 **호이스팅**합니다!

<!-- 호이스팅에 대한 내용 추가 -->

```js
const result = sum(1, 2);

console.log(result);  // 3

function sum(a, b){
  return a + b;
}
```

오, 작동하네요? 그럼 저희는 이렇게 생각할 수 있습니다. *호이스팅이 발생하는구나!*

자바스크립트는 모든 선언문이 **선언되기 이전에 참조가 가능**합니다. 함수 선언문으로 정의된 함수가 평가되는 과정은 아래와 같습니다.
1. 자바스크립트 엔진이 스크립트가 로딩되는 **시점**에 초기화 합니다.
2. 초기화된 함수를 변수 객체(Variable Object, VO)에 저장합니다.

이렇게 함수의 선언, 초기화, 할당이 한 프로세스에서 이루어지는 것입니다! 그럼 당연히 함수 선언의 위치와 상관 없이 어느 곳에서든 호출이 가능하죠.

```js
const result = sum(1, 2);

console.log(result);  // TypeError: sum is not a function

const sum = function(a, b){
  return a + b;
}
```

그렇지만 함수 표현식은 함수 호이스팅이 아닌 **변수 호이스팅**이 발생합니다. 변수 호이스팅은 함수 호이스팅과 그 과정이 다릅니다. 아래를 볼까요?
1. 함수 표현식은 `런타임(Runtime)`에 해석되고 실행되므로 변수 생성과 초기화, 할당이 분리되어 진행됩니다.
2. 호이스팅된 변수는 undefined로 초기화됩니다.
3. 실제로 값의 할당은 `할당문`에서 이루어집니다!

함수 호이스팅은 함수 호출 전에 반드시 함수를 선언해야 된다는 규칙을 무시하기 때문에 코드의 구조적 결함이 발생할 수 있으므로 **함수 표현식**을 사용하도록 권장합니다.